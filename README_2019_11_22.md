
# **Inbae Kang**

## 1.Structure
**ROS in GUAVA**
  - There are four packages in GUAVA(Grab UAV Accurately) project.
    - main : Package that give orders to other packages and Receive Result from each packages.
    - radar : Package that get raw data using radar, make SAR image and classify object.
    - camera : Package that take a picture and classify object.
    - rail : Package that control movement of rail needed for making SAR image.
  - And each package consist of nodes, messages and topics.
  - Each node publishes a message to a topic or subscribes topic to get a message from other nodes.
  - Especially, I mainly implement main package. More details about nodes in main package is following
    - decision : give signal to initialize, start, end to radar, camera and rail node and get result from these nodes.
    - storage : save raw data and result data from other packages.
    - log : write log of entire system. All nodes in GUAVA publish to ‘logs’ topic.
    - web : visualize result made by decision node.

![structure](https://i.imgur.com/poalF5m.jpg)

## 2.Rehearsal
  1. ROSCORE is run on the main package. The rest of the rail / radar nodes and camera nodes run a shell script to set up the execution environment. Main Raspberry Pi is localhost and Camera and Radar Raspberry Pi are configured to communicate on ROS by setting ROS_MASTER_URI to the IP address of main Raspberry Pi / PC.
  2. Each node is executed in camera and radar Raspberry Pi (by shell script named <package_name> .sh), log, storage, web nodes are executed in order in main package, finally decision node is executed. Send an init message to the operate topic.
  3. The rail and camera packages complete their initialization, and the rail node sends a message to the rail_end topic indicating that the rail has finished initializing. The decision node receiving the message goes from the init phase to the start phase.
  4. The Decision node sends a start message to the operate topic.
  5. The three nodes that received the message 1. The rail node moves the rail over 74 seconds. 2. The radar node starts collecting binary data. 2. The Camera node starts collecting data. While collecting data, the Decision node receives real-time data through the realtime_camera topic, stores it in the storage node, and passes the file path and result value to the web node to show the result_web topic.
  6. When the rail reaches the end, it posts a message to the rail_end topic that the cycle is over and the decision node that receives the message goes to the end phase.
  7. The decision node subscribed to that topic sends a message to the end topic telling the camera and radar to stop collecting data.
  8. The radar package publishes the binary data accumulated so far to the raw topic. The storage node stores the raw file.
  9. Publish for make_sar_image node to receive after conversion to IFFT and wav data.
  10. Create a SAR image and pass it to the decision node
  11. The Camera package creates a summary of the photos so far and sends a message to the summary_camera.
  12. RADAR and CAMERA publish to the result_radar and summary_camera topics, respectively, so that the Decision node receives it and delivers it to the storage node.
 
## 3.Message Definition

### Radar Package

- radar/railstart : 데이터 수집을 시작하기 위해서 Rail이 움직이도록 보내는 메시지
```
    bool start
    bool direction #움직일 방향
```
- radar/railstop : 레일이 끝에 도달하여 끝났다는 것을 알리기 위한 메시지.
```
    bool terminate
```
- radar/raw : 수집된 raw데이터.
```
    uint8[] data
    uint64 num #데이터 잘랐을 때, 디버깅용으로 사용.
```
- radar/wav : 변환된 데이터
```
    uint16[] data #두번째 5bit가 여기
    uint16[] sync #첫번째 3bit가 여기
    uint64 num #위와 동일
    uint64 sr #sample rate
```
- radar/result_radar → sensor_msgs/Image

### Camera Pacakage

- camera/sendframe
```
    float64[] coords
    float64 percent
    string operate
    sensor_msgs/Image frame
```
- camera/sendsummary
```
    float64 percent
    string direction
    sensor_msgs/Image frame
```
### Rail Package

- rail_end → std_msgs/String

### Main Pacakge

- main/operate,end
```
    string command
    bool direction
```
- main/result
```
    float64 percent_camera
    float64[] coords_camera
    float64 percent_radar
    sensor_msgs/Image image_camera
    sensor_msgs/Image image_radar
    string direction
```
- main/realtime
```
    float64[] coords
    float64 percent
    sensor_msgs/Image frame
```
- main/result_web
```
    float64 percent_camera
    float64[] coords_camera
    float64 percent_radar
    string image_camera
    string image_radar
    string direction
```
- log → std_msgs/String

---
# radar readme

## Youngjin Kim

I was correcting codes for SAR image. And finally succeed at making SAR image. but We don't know output image is correct or not.
To resolve issues when making SAR image before, I changed some parameters for making SAR image. First, adjust radar frequency value to 2.35GHz~2.5GHz. This Information can found using Oscilloscope  and RF data sheet. Under is photo of oscilloscope, connected to our radar.

 

![](C67CDA89-E725-4C37-9EE3-200D4625BEE2-fee65a73-cedf-485e-ab07-a2b8433e14b5.heic)

As you can see in oscilloscope, crossing point( + ) of white lines is point A, crossing point ( + ) of orange line is point B. The yellow line which looks like continuous triangle is our radar signal.  So, we can check ramp-up time is 20.00ms (delta X) and also one cycle time is 40.00ms. Voltage of point A is 0.5V, point B is 1.74V. We can find out radar frequency using this information and data sheet below.

![](8B0C5523-B951-4AF9-8DC2-A9FC58387067-a04339d1-6344-4ebf-a463-012ae4db2ea2.png)

So, at voltage 0.5, our radar's frequency is 2.35GHz and at voltage 1.74, it is 2.5GHz.

After finish adjusting radar frequency, we found out Sampling rate of our radar is little werid. We thought sample rate of our radar is 5862 per second and it is constant. But, it was variable.  There is parameter which name is minimum_silence_len, It is used for calculate number of samples in ramp up time. If sample rate is 5862, minimum_silence_len should be 5862 * 0.02 = 117.24 (=117).  This means there should be 117 silent (Sync False) samples between each Frame. Our sync data is consecutive Trues follows consecutive Falses repeats.(True True ... True False False ... False True ...) I wonder how many same syncs repeats? Is this length fixed? So, I wrote a code to calculate.

    import numpy as np
    #sync : parsed sync data
    d=np.diff(sync)
    idx, = d.nonzero()
    for i in range(1,len(idx)-1) :
        idx[i] = idx[i+1] - idx[i]
    dic={}
    for i in idx[1:-1] :
        dic[i] = 1 if dic.get(i) == None else dic[i] + 1
    for key, value in dic.items() :
        print(key,' : ',value)

And output of this code when input is "20191120_193611_binary.txt" (It is in our github repository, in test_data directory) is below.

![](Screen_Shot_2019-11-22_at_4-313ba11a-c2fb-46cf-b41e-ee28b63c72c0.31.51_PM.png)

As you can see, length of consecutive is changing. And most of values of length is between 115~117. In case of realtime plotting code, receiver crops data in 1 second period, so I changed receiver code to calculate sample rate every single second and send it to analyzer with raw data. And in case of SAR image plotting code, we decided to calculate sample rate with whole samples divided by whole time. It is estimated mean of 5917 during experiment. Now there's a problem of deciding value of minimum_silence_len parameter. I think we can get good result of SAR image if we can analyze and correct this value.

---
